ORG  00H 
RS  EQU P3.0 
   RW  EQU P3.1 
   E  EQU P3.2 
   RDADC EQU P3.3 
   WRADC EQU P3.4 
   INTR EQU P3.5 
   CLR P3.6 
   CLR P3.7 
   MOV  R0, #30H  ; Pointer to store first ASCII digit 
   MOV  R2, #00H  ; Counter for enter 
   MOV R1, #40H ;Pointer to store first temperature 
   MOV 43H,#80H; critical temperature at 43H 
LCD_IN:MOV  A, #38H   ; init. LCD 2 lines, 5x7 matrix  
   ACALL COMNWRT   ; call command subroutine  
   ACALL  DELAY   ; give LCD some time  
   MOV   A, #0FH   ; display on, cursor on  
   ACALL COMNWRT   ; call command subroutine  
   ACALL  DELAY   ; give LCD some time  
   MOV  A, #01    ; clear LCD  
   ACALL COMNWRT   ; call command subroutine  
   ACALL  DELAY   ; give LCD some time  
   MOV  A, #06H  
   ACALL  COMNWRT 
   ACALL  DELAY 
   MOV A, #80H   ;cursor at line 1 postion 5  
LCALL COMNWRT  ;call command subroutine  
   LCALL  DELAY 
   CLR A 
   MOV DPTR,#M1 
   ACALL MSG  
   MOV A, #0C0H   ;cursor at line 1 postion 5  
   LCALL COMNWRT  ;call command subroutine  
   LCALL  DELAY 
    
KEYPAD:MOV   A, #0FH     ; make P1.0 - P1.3 input  
   MOV  P2, A 
K1: MOV  A, P2    ; read all columns, ensure all keys open  
   ANL  A, #00001111B  ; mask unused bits  
   CJNE  A, #00001111B, K1  ; check till all keys released   
K2:  ACALL  DELAY   ; call 20ms delay  
   MOV  A, P2    ; see if any key is pressed  
   ANL  A, #00001111B  ; mask unused bits  
   CJNE   A, #00001111B, OVER ; key pressed, await closure 
   SJMP  K2    ; check if key pressed  
OVER:  ACALL  DELAY   ; wait 20ms debounce time  
   MOV  A, P2    ; check key closure  
   ANL  A, #00001111B  ; mask unused bits  
   CJNE  A, #00001111B, OVER1 ; key pressed, find row   
   SJMP  K2    ; if none, keep polling  
OVER1:  SETB P2.7 
   SETB P2.6 
   SETB P2.5 
   CLR P2.4 ; Ground row 0 (P1.4 = 0), keep P1.0-P1.3 as inputs 
   MOV  A, P2   
   ANL  A, #11101111B    ; Mask unused bits 
CJNE A, #11101111B  , ROW_0  
   SETB P2.7 
   SETB P2.6 
   SETB P2.4 
   CLR P2.5; Ground row 1 (P1.5 = 0) 
   MOV  A, P2   
   ANL  A, #11011111B   
   CJNE A, #11011111B , ROW_1 
   SETB P2.7 
   SETB P2.5 
   SETB P2.4 
   CLR P2.6 ; Ground row 2 (P1.6 = 0) 
   MOV  A, P2   
   ANL  A, #10111111B  
   CJNE A, #10111111B , ROW_2 
   SETB P2.6 
   SETB P2.5 
   SETB P2.4 
   CLR P2.7 ; Ground row 3 (P1.7 = 0) 
   MOV  A, P2   
   ANL  A, #01111111B  
   CJNE A, #01111111B, ROW_3 
   LJMP  K2  
ROW_0:  MOV  DPTR,  #KCODE0  ; set DPTR=start of row 0  
   CLR P2.7 
   CLR P2.6 
   CLR P2.5 
   CLR P2.4 
   SJMP  FIND    ; find column key belongs to  
ROW_1:  MOV  DPTR, #KCODE1  ; set DPTR=start of row 1  
   CLR P2.7 
   CLR P2.6 
   CLR P2.5 
   CLR P2.4 
   SJMP  FIND    ; find column key belongs to  
ROW_2:  MOV  DPTR, #KCODE2  ; set DPTR=start of row 2  
   CLR P2.7 
   CLR P2.6 
   CLR P2.5 
   CLR P2.4 
   SJMP  FIND    ; find column key belongs to  
ROW_3:  MOV  DPTR, #KCODE3  ; set DPTR=start of row 3  
   CLR P2.7 
   CLR P2.6 
   CLR P2.5 
   CLR P2.4 
FIND:  RRC  A    ; see if any CY bit is low  
   JNC  MATCH   ; if zero, get the ASCII code  
   INC  DPTR    ; point to the next column address  
   SJMP  FIND    ; keep searching  
MATCH:   CLR  A     
   MOVC  A, @A+DPTR  ; get ASCII code from table  
   ACALL DATAWRT 
   ACALL DELAY 
   ANL A,#0FH; 33H and 0FH = 03H 
   MOV @R0,A 
   INC R0 
   INC R2 
   CJNE R2,#2,FOURDIGIT 
   ACALL FIRSTLINE 
MOV DPTR,#M2 
ACALL MSG 
ACALL SECONDLINE  
SJMP NXT 
FOURDIGIT:CJNE R2,#4,SIXDIGIT 
ACALL FIRSTLINE 
MOV DPTR,#M3 
ACALL MSG 
ACALL SECONDLINE  
SJMP NXT 
SIXDIGIT:CJNE R2,#6,NXT 
ACALL STORETEMP 
ACALL FIRSTLINE 
MOV DPTR,#M4 
ACALL MSG 
SJMP ADCCODE;R2 is free register now 
NXT:LJMP KEYPAD 
ADCCODE:MOV P1, #0FFH 
SETB INTR 
BACK:CLR WRADC 
SETB WRADC 
CHECK:JB INTR,CHECK 
CLR RDADC 
MOV A,P1 
ACALL CONVERSION 
MOV A,#0CH 
ACALL COMNWRT 
ACALL DELAY 
ACALL SECONDLINE 
ACALL DISPLAYDATA 
SJMP COMPARE 
SETB RDADC 
SJMP BACK 
COMPARE:CLR C 
MOV A,R7;A=sensor temp 
MOV R1,#40H 
MOV B,@R1;Tmin 
CJNE A,B,BELOWTMIN 
BELOWTMIN:JNC RANGE2;A>B=sensor temp>Tmin 
CLR P3.6;sensor temp<Tmin,motor off 
ACALL FIRSTLINE 
MOV DPTR,#M5 
ACALL MSG 
SJMP $ 
RANGE2:INC R1 
MOV B,@R1;Tmed 
CJNE A,B,TMINTMED 
TMINTMED:JNC RANGE3;A>B=sensor temp>Tmed 
ACALL FIRSTLINE 
MOV DPTR,#M6 
ACALL MSG 
LOW:ACALL LOW_SPEED;A<B=sensor temp<Tmed;Tmin<sensor temp 
ACALL AUTO_SHUT 
SJMP LOW 
RANGE3:INC R1 
   MOV B,@R1;Tmax 
   CJNE A,B,TMEDTMAX 
TMEDTMAX:JNC RANGE4;A>B=sensor temp>Tmax 
   ACALL FIRSTLINE 
   MOV DPTR,#M7 
   ACALL MSG 
MED:ACALL MED_SPEED;A<B= sensor temp<Tmax;Tmed<sensor temp 
    ACALL AUTO_SHUT 
   SJMP MED 
RANGE4:INC R1 
   MOV B,@R1;Tcritical 
   CJNE A,B,TMAXTCRIT 
TMAXTCRIT:JNC STOPALERT;A>B=sensor temp>Tcritical 
   ACALL FIRSTLINE 
   MOV DPTR,#M8 
   ACALL MSG 
HIGH:ACALL HIGH_SPEED;A<B= sensor temp<Tcritical;Tmax<sensor temp 
    ACALL AUTO_SHUT 
   SJMP HIGH 
STOPALERT:CLR P3.6 
   ACALL FIRSTLINE 
   MOV DPTR,#M9 
   ACALL MSG 
   SJMP $ 
;AUTO SHUTDOWN ROUTINE------------------- 
AUTO_SHUT: 
    MOV TMOD, #01H 
    MOV R3, #20 
    OUTER_LOOP_T: MOV R4, #250 
    START_TIMER: MOV TH0, #0B6H 
    MOV TL0, #00H 
    SETB TR0 
    WAIT_TIMER: JNB TF0, WAIT_TIMER 
    CLR TR0  
   CLR TF0 
    DJNZ R4, START_TIMER 
    DJNZ R3, OUTER_LOOP_T 
    CLR P3.6 
    SJMP $ 
COMNWRT: LCALL READY   ;send command to LCD  
   MOV  P0, A    ;copy reg A to port 1  
   CLR  RS    ;RS=0 for command  
   CLR  RW    ;R/W=0 for write  
   SETB  E    ;E-1 for high pulse   
   ACALL DELAY   ;give LCD some time  
   CLR  E    ;E=0 for H-to-L pulse  
   RET  
  
DATAWRT: LCALL READY   ;write data to LCD  
   MOV  P0, A    ;copy reg A to port1  
   SETB  RS    ;RS=1 for data  
   CLR  RW    ;R/W=0 for write  
   SETB  E    ;E=1 for high pulse  
   ACALL DELAY   ;give LCD some time  
   CLR  E    ;E=0 for H-to-L pulse  
   RET  
 
READY:  SETB  P0.7  
   CLR  RS  
   SETB  RW  
WAIT:  CLR  E  
   LCALL DELAY  
   SETB  E  
   JB  P0.7, WAIT  
   RET 
     
DELAY:  MOV  R3, #50   ;50 or higher for fast CPUs  
HERE2:  MOV  R4, #255   ;R4=255  
HERE:  DJNZ  R4, HERE   ;stay untill R4 becomes 0  
   DJNZ   R3, HERE2  
   RET  
 
MSG: CLR A 
   MOVC  A,@A+DPTR  
   JZ  DONE 
   LCALL  DATAWRT  
   LCALL  DELAY  
   INC  DPTR  
   LJMP  MSG 
DONE:RET 
 
FIRSTLINE:MOV  A, #01    ; clear LCD  
   ACALL COMNWRT   ; call command subroutine  
   ACALL  DELAY   ; give LCD some time  
   MOV  A, #06H  
   ACALL  COMNWRT 
   ACALL  DELAY 
   MOV A, #80H   ;cursor at line 1 postion 5  
   LCALL COMNWRT  ;call command subroutine  
   LCALL  DELAY 
   RET 
 
SECONDLINE:MOV  A, #0C0H    ; clear LCD  
   ACALL COMNWRT   ; call command subroutine  
   ACALL  DELAY 
   RET 
 
STORETEMP:MOV R0,#30H 
   MOV R5,#3 
STORELOOP:MOV A,@R0 
    MOV B,#10 
    MUL AB 
    MOV R6,A;R6 as temporary space 
    INC R0 
    MOV A,@R0 
    ADD A,R6 
    MOV @R1,A;40H=Tmin,41H=Tmed,42H=Tmax 
    INC R1 
    INC R0;R0 is free register 
    DJNZ R5,STORELOOP;R5 is free register now 
    RET 
 
CONVERSION:MOV B,#2 
   MOV A,P1 
MUL AB  
MOV R7,A;sensor temp in R7   
MOV B,#10 
DIV AB 
ORL A,#30H    
MOV 70H,A 
MOV A,B 
ORL A,#30H 
MOV 71H,A 
RET 
; Convert to ASCII for display 
DISPLAYDATA:MOV A ,70H 
ACALL DATAWRT 
ACALL DELAY 
MOV A,71H 
ACALL DATAWRT 
ACALL DELAY 
RET 
LOW_SPEED:SETB P3.6 
MOV R6, #30 
ACALL DELAY2 
CLR P3.6 
MOV R6, #70 
ACALL DELAY2 
RET 
MED_SPEED:SETB P3.6 
MOV R6, #60 
ACALL DELAY2 
CLR P3.6 
MOV R6, #40 
ACALL DELAY2 
RET 
HIGH_SPEED: SETB P3.6 
MOV R6, #90 
ACALL DELAY2 
CLR P3.6 
MOV R6, #10 
ACALL DELAY2 
RET 
DELAY2: 
H11: MOV R2, #100 
H12: MOV R5, #255 
H13: DJNZ R5, H13 
DJNZ R2, H12 
DJNZ R6, H11 
RET 
KCODE0: DB '7','8','9','*'    
; ROW 0  
KCODE1: DB '4','5','6','*'   ; ROW 1  
KCODE2: DB '1','2','3','*'   ; ROW 2  
KCODE3: DB 'S','0','T','*'    
; ROW 3 
M1: DB 'ENTER MIN',0 
M2: DB 'ENTER MED',0 
M3: DB 'ENTER MAX',0 
M4: DB 'ROOM TEMPERATURE',0 
M5: DB 'MOTOR OFF',0 
M6: DB 'LOW SPEED',0 
M7: DB 'MEDIUM SPEED',0 
M8: DB 'HIGH SPEED',0 
M9: DB 'CRITICAL TEMP',0 
END 
